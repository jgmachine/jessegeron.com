---
/**
 * BoardGameArena Spider/Radar Chart Component
 *
 * Radial chart showing game proficiency across 3 dimensions:
 * - ELO rating (skill)
 * - Win rate (success)
 * - Games played (experience)
 *
 * Interactive: hover to highlight, click to toggle visibility.
 */
import type { BGAGameStats } from "../lib/bga";

interface Props {
  games: BGAGameStats[];
  limit?: number;
  minMatches?: number;
}

const { games, limit = 5, minMatches = 5 } = Astro.props;

// Filter games that have all three metrics, meet minimum matches, and sort by composite score
const validGames = games
  .filter((g) =>
    g.elo !== undefined &&
    g.matches !== undefined &&
    g.wins !== undefined &&
    (g.matches || 0) >= minMatches
  )
  .map((g) => ({
    ...g,
    winRate: g.matches && g.wins !== undefined ? Math.round((g.wins / g.matches) * 100) : 0,
  }))
  .sort((a, b) => {
    // Sort by composite score: normalize and combine ELO, win rate, and matches
    const scoreA = (a.elo || 0) + (a.winRate || 0) + (a.matches || 0) * 2;
    const scoreB = (b.elo || 0) + (b.winRate || 0) + (b.matches || 0) * 2;
    return scoreB - scoreA;
  })
  .slice(0, limit);

// Find max values for normalization (use reasonable minimums for better scaling)
const maxElo = Math.max(...validGames.map((g) => g.elo || 0), 150);
const maxMatches = Math.max(...validGames.map((g) => g.matches || 0), 15);
const maxWinRate = 100;

// Normalize values to 0-1 scale
function normalize(value: number, max: number): number {
  return Math.max(0, Math.min(1, value / max));
}

// Chart dimensions
const size = 320;
const center = size / 2;
const maxRadius = 100;
const labelRadius = maxRadius + 35;

// Three axes at 120 degrees apart
const axes = [
  { label: "ELO", angle: -90 }, // Top
  { label: "Win %", angle: 30 }, // Bottom right
  { label: "Played", angle: 150 }, // Bottom left
];

// Convert polar to cartesian coordinates
function polarToCartesian(angle: number, radius: number): { x: number; y: number } {
  const radians = (angle * Math.PI) / 180;
  return {
    x: center + radius * Math.cos(radians),
    y: center + radius * Math.sin(radians),
  };
}

// Generate polygon points for a game
function getPolygonPoints(game: (typeof validGames)[0]): string {
  const eloNorm = normalize(game.elo || 0, maxElo);
  const winNorm = normalize(game.winRate || 0, maxWinRate);
  const matchesNorm = normalize(game.matches || 0, maxMatches);

  const values = [eloNorm, winNorm, matchesNorm];

  return axes
    .map((axis, i) => {
      const radius = values[i] * maxRadius;
      const { x, y } = polarToCartesian(axis.angle, radius);
      return `${x},${y}`;
    })
    .join(" ");
}

// Generate data points for a game
function getDataPoints(game: (typeof validGames)[0]): { x: number; y: number }[] {
  const eloNorm = normalize(game.elo || 0, maxElo);
  const winNorm = normalize(game.winRate || 0, maxWinRate);
  const matchesNorm = normalize(game.matches || 0, maxMatches);
  const values = [eloNorm, winNorm, matchesNorm];

  return axes.map((axis, i) => {
    const radius = values[i] * maxRadius;
    return polarToCartesian(axis.angle, radius);
  });
}

// Generate grid rings
const gridRings = [0.25, 0.5, 0.75, 1.0];

// Color palette for 10 games (distinct, accessible colors)
const gameColors = [
  { stroke: "#6366f1", fill: "rgba(99, 102, 241, 0.2)" },   // Indigo
  { stroke: "#10b981", fill: "rgba(16, 185, 129, 0.2)" },   // Emerald
  { stroke: "#f59e0b", fill: "rgba(245, 158, 11, 0.2)" },   // Amber
  { stroke: "#ef4444", fill: "rgba(239, 68, 68, 0.2)" },    // Red
  { stroke: "#8b5cf6", fill: "rgba(139, 92, 246, 0.2)" },   // Violet
  { stroke: "#06b6d4", fill: "rgba(6, 182, 212, 0.2)" },    // Cyan
  { stroke: "#ec4899", fill: "rgba(236, 72, 153, 0.2)" },   // Pink
  { stroke: "#84cc16", fill: "rgba(132, 204, 22, 0.2)" },   // Lime
  { stroke: "#f97316", fill: "rgba(249, 115, 22, 0.2)" },   // Orange
  { stroke: "#0ea5e9", fill: "rgba(14, 165, 233, 0.2)" },   // Sky blue
];

// Prepare game data for client-side JS
const gameData = validGames.map((game, index) => ({
  id: `game-${index}`,
  name: game.name,
  elo: game.elo,
  winRate: game.winRate,
  matches: game.matches,
  points: getPolygonPoints(game),
  dataPoints: getDataPoints(game),
  color: gameColors[index % gameColors.length],
}));
---

<div class="bg-white rounded-lg p-5 border border-gray-200 shadow-sm">
  <h3 class="text-base font-bold text-gray-900 mb-1">Game Proficiency</h3>
  <p class="text-xs text-gray-500 mb-4">
    Top {validGames.length} games ({minMatches}+ matches). Click to toggle, hover to highlight.
  </p>

  <div class="flex flex-col md:flex-row gap-6 items-center">
    <!-- SVG Chart -->
    <div class="flex-shrink-0" id="spider-chart-container">
      <svg
        viewBox={`0 0 ${size} ${size}`}
        class="w-[320px] h-[320px]"
        role="img"
        aria-label="Spider chart showing game proficiency"
        id="spider-chart"
      >
        <!-- Grid rings -->
        {gridRings.map((ring) => {
          const points = axes
            .map((axis) => {
              const { x, y } = polarToCartesian(axis.angle, ring * maxRadius);
              return `${x},${y}`;
            })
            .join(" ");
          return (
            <polygon
              points={points}
              fill="none"
              stroke="#e5e7eb"
              stroke-width="1"
            />
          );
        })}

        <!-- Axis lines -->
        {axes.map((axis) => {
          const { x, y } = polarToCartesian(axis.angle, maxRadius);
          return (
            <line
              x1={center}
              y1={center}
              x2={x}
              y2={y}
              stroke="#d1d5db"
              stroke-width="1"
            />
          );
        })}

        <!-- Axis labels -->
        {axes.map((axis) => {
          const { x, y } = polarToCartesian(axis.angle, labelRadius);
          const textAnchor =
            axis.angle === -90 ? "middle" : axis.angle < 0 ? "start" : axis.angle > 90 ? "end" : "start";
          const dy = axis.angle === -90 ? "0" : "0.35em";
          return (
            <text
              x={x}
              y={y}
              text-anchor={textAnchor}
              dy={dy}
              class="text-xs fill-gray-600 font-medium"
            >
              {axis.label}
            </text>
          );
        })}

        <!-- Game polygons group -->
        <g id="polygons-group">
          {gameData.map((game) => (
            <g id={`polygon-${game.id}`} class="game-polygon" data-game-id={game.id}>
              <polygon
                points={game.points}
                fill={game.color.fill}
                stroke={game.color.stroke}
                stroke-width="2"
                class="transition-all duration-200"
              />
              {game.dataPoints.map((point) => (
                <circle
                  cx={point.x}
                  cy={point.y}
                  r="4"
                  fill={game.color.stroke}
                  class="transition-all duration-200"
                />
              ))}
            </g>
          ))}
        </g>
      </svg>
    </div>

    <!-- Legend -->
    <div class="flex-1">
      <div class="space-y-1">
        {gameData.map((game) => (
          <button
            type="button"
            class="game-legend-item flex items-center gap-2 py-1 px-2 rounded hover:bg-gray-50 transition-all duration-200 cursor-pointer text-left w-full"
            data-game-id={game.id}
            data-active="true"
          >
            <div
              class="w-3.5 h-3.5 rounded-sm flex-shrink-0 border-2 transition-all duration-200"
              style={`background-color: ${game.color.fill}; border-color: ${game.color.stroke}`}
              data-color-box="true"
            />
            <span class="text-sm font-medium text-gray-900 flex-1" title={game.name}>
              {game.name}
            </span>
            <span class="text-xs text-gray-500 flex-shrink-0 tabular-nums">
              {game.elo} · {game.winRate}% · {game.matches}x
            </span>
          </button>
        ))}
      </div>

      <!-- Scale reference -->
      <div class="mt-3 pt-2 border-t border-gray-100">
        <div class="flex flex-wrap gap-3 text-xs text-gray-400">
          <span>Max: {maxElo} ELO</span>
          <span>{maxWinRate}% win</span>
          <span>{maxMatches} played</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Interactive spider chart functionality
  document.addEventListener('DOMContentLoaded', () => {
    const legendItems = document.querySelectorAll('.game-legend-item');
    const polygonsGroup = document.getElementById('polygons-group');

    if (!polygonsGroup) return;

    legendItems.forEach((item) => {
      const gameId = item.getAttribute('data-game-id');
      const polygon = document.getElementById(`polygon-${gameId}`);
      const colorBox = item.querySelector('[data-color-box]') as HTMLElement;
      const toggleHint = item.querySelector('.toggle-hint');

      if (!polygon || !colorBox) return;

      // Hover: highlight this game, dim others
      item.addEventListener('mouseenter', () => {
        const isActive = item.getAttribute('data-active') === 'true';
        if (!isActive) return;

        // Dim all other active polygons
        document.querySelectorAll('.game-polygon').forEach((p) => {
          const pId = p.getAttribute('data-game-id');
          const pItem = document.querySelector(`.game-legend-item[data-game-id="${pId}"]`);
          const pActive = pItem?.getAttribute('data-active') === 'true';

          if (pId !== gameId && pActive) {
            (p as SVGElement).style.opacity = '0.2';
          }
        });

        // Highlight this polygon
        polygon.style.opacity = '1';
        (polygon.querySelector('polygon') as SVGElement).style.strokeWidth = '3';
      });

      item.addEventListener('mouseleave', () => {
        // Restore all active polygons
        document.querySelectorAll('.game-polygon').forEach((p) => {
          const pId = p.getAttribute('data-game-id');
          const pItem = document.querySelector(`.game-legend-item[data-game-id="${pId}"]`);
          const pActive = pItem?.getAttribute('data-active') === 'true';

          (p as SVGElement).style.opacity = pActive ? '1' : '0';
          (p.querySelector('polygon') as SVGElement).style.strokeWidth = '2';
        });
      });

      // Click: toggle visibility
      item.addEventListener('click', () => {
        const isActive = item.getAttribute('data-active') === 'true';
        const newActive = !isActive;

        item.setAttribute('data-active', String(newActive));

        if (newActive) {
          // Show
          polygon.style.opacity = '1';
          polygon.style.pointerEvents = 'auto';
          colorBox.style.opacity = '1';
          item.classList.remove('opacity-50');
          if (toggleHint) toggleHint.textContent = 'click to hide';
        } else {
          // Hide
          polygon.style.opacity = '0';
          polygon.style.pointerEvents = 'none';
          colorBox.style.opacity = '0.3';
          item.classList.add('opacity-50');
          if (toggleHint) toggleHint.textContent = 'click to show';
        }
      });
    });
  });
</script>

<style>
  .game-legend-item:hover .toggle-hint {
    opacity: 1;
  }

  .game-legend-item .toggle-hint {
    opacity: 0;
    transition: opacity 0.2s;
  }

  .game-polygon {
    transition: opacity 0.2s ease-out;
  }
</style>
